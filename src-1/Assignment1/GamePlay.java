// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------
//Ankita Sharma

package Assignment1;
import java.util.Random;
import java.util.List;

/**
 * The GamePlay class serves as a the central controller for the Catan simulation.
 * It manages the iterative game loop, coordinated resource production between the board
 * and agents, and monitors victory conditions. 
*/
public class GamePlay {
	
	private int roundNumber = 0;
	private final List<Agent> agents;
	private final Board board;
	private final Dice dice;
	private final int maxRounds;
	private final Random random = new Random();

	/**
	 * Initializes the simulation controller with necessary game components.
	 * @param agents		The array of 4 agents participating agents.
	 * @param board			The game board contaning tiles, nodes, and edges.
	 * @param die			The multi-dice component for rolling.
	 * @param maxRounds		The limit of rounds to simulate before termination.
	*/
	public GamePlay(List<Agent> agents, Board board, Dice dice, int maxRounds){
		this.agents = agents;
		this.board = board;
		this.dice = dice;
		this.maxRounds = maxRounds;
	}


	/** 
	 * Executes the main simulation loop. The process continues until an agent 
	 * reaches 10 victory points or the maximum round limit is reached.
	*/
	public void runSimulation() {
		boolean victoryAchieved = false;

		while (roundNumber < maxRounds && !victoryAchieved) {
			roundNumber++;
			for (Agent activeAgent : agents) {
				executeTurn(activeAgent);

				if (activeAgent.getVictoryPoints() >= 10){
					victoryAchieved = true;
					break;
				}
			}
			printRoundSummary();
		}
	}

	/**
	 * Handles the logic for an individual agent's turn, including resource production and
	 * mandatory building actions if resources exceed limits.
	 * @param agent	The agent currently taking their turn.
	 */
	private void executeTurn(Agent agent){
		int roll = dice.roll();

		//Resource production occurs for any roll except a 7
		if (roll != 7){
			distributeResources(roll);
		}

		//Agent with high card counts must attempt to spend them by building 
		//Logic for hand size check would be implemented here based on Agent list size
		performRandomBuildAction(agent);
	}


	/**
	 * Matches the current dice roll against tile values on the board and distributes 
	 * the corresponding resources to agents with adjacent buildings.
	 * @param roll	The integer value resulting from the dice roll.
	 */
	private void distributeResources(int roll){
		//Iterate through all 19 tiles (0-18) as per the specification 
		for (int i = 0; i < 19; i++){
			Tile currentTile = board.getTile(i);

			//Check if the tile's number token matches the dice roll
			if (currentTile.getRollValue() == roll){
				Resources producedResource = currentTile.getResourceType();

				//Get the 6 nodes surrounding this hex
				for (Node adjacentNode : currentTile.getAdjacentNodes()) {
					Building building = board.getBuildingAtNode(adjacentNode);

					if (building != null){
						Agent owner = building.getAgent();
						int amount = (building instanceof City) ? 2 : 1; 

						for (int j = 0; j < amount; j++){
							owner.addResource(producedResource);
						}
					}
				}
			} 
		}		
	
	}

	/**
	 * Conducts a linear check of potential building actions and executes
	 * one randomly to ensure agents manage their resources effectively.
	 * @param agent		The agent performing a build action
	 */
	private void performRandomBuildAction(Agent agent){
		//Linear check of all building possibilities.
		List<Node> validSettlementSpots = new ArrayList<>();

		//Example: Checking all 54 nodes for valid settlement placement
		for (int i = 0; i < 54; i++){
			Node currentNode = board.getNode(i);
			if (canAgentBuildSettlement(agent, currentNode)){
				validSettlementSpots.add(currentNode);
			}
		}

		//Pick one randomly from the valid options
		if (!validSettlementSpots.isEmpty()){
			Node chosenSpot = validSettlementSpots.get(random.nextInt(validSettlementSpots.size()));
			board.placeBuilding(new Settlement(agent), chosenSpot);
			//Deduct resources logic here
		}
	}


	/**
	 * Outputs the current state of the simulation to the console using 
	 * the spcified format for round tracking and agent actions.
	 */
	private void printRoundSummary(Agent agent){
		//Formats: [RoundNumber / [PlayerID]: [Action]]
		for (Agent a : agents){
			System.out.println("[" + roundNumber + " / " + a.getName() + "]: Status Updated");
			System.out.println("Current Victory Points: " + a.getVictoryPoints());	
		}
	}

	/**
	 * 
	 * @return 
	 */
	public int getTurnNumber() {
		return 0;
	}

}//ends class GamePlay
